<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Simulation</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="control-panel">
    <div class="control-group">
        <label>Hover distance: <span class="slider-value"><span id="distance-value">0.1</span> in</span></label>
        <input type="range" id="pen-distance" min="0" max="1" step="0.1" value="0">
    </div>

    <div class="control-group">
        <label>Tilt altitude: <span class="slider-value"><span id="altitude-value">30</span>°</span></label>
        <input type="range" id="tilt-altitude" min="0" max="60" step="1" value="30">
    </div>

    <div class="control-group">
        <label>Tilt azimuth: <span class="slider-value"><span id="azimuth-value">0</span>°</span></label>
        <input type="range" id="tilt-azimuth" min="0" max="359" step="1" value="0">
    </div>

    <div class="control-group">
        <label>Tilt X: <span class="slider-value"><span id="tilt-x-value">0.0</span>°</span></label>
    </div>

    <div class="control-group">
        <label>Tilt Y: <span class="slider-value"><span id="tilt-y-value">0.0</span>°</span></label>
    </div>

    <div class="control-group">
        <label>Barrel rotation: <span class="slider-value"><span id="barrel-rotation-value">0</span>°</span></label>
        <input type="range" id="barrel-rotation" min="0" max="359" step="1" value="0">
    </div>

    <div class="control-group">
        <label>X: <span class="slider-value"><span id="tablet-position-x-value">0.0</span> in</span></label>
        <input type="range" id="tablet-position-x" min="-8" max="8" step="0.1" value="0">
    </div>

    <div class="control-group">
        <label>Y: <span class="slider-value"><span id="tablet-position-z-value">0.0</span> in</span></label>
        <input type="range" id="tablet-position-z" min="-4.5" max="4.5" step="0.1" value="0">
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="axonometric-view" style="width: auto; margin: 0;">
            <span>Axonometric</span>
        </label>
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="azimuth-annotations" checked style="width: auto; margin: 0;">
            <span>Tilt azimuth</span>
        </label>
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="altitude-annotations" checked style="width: auto; margin: 0;">
            <span>Tilt altitude</span>
        </label>
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="barrel-annotations" checked style="width: auto; margin: 0;">
            <span>Barrel rotation</span>
        </label>
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="tilt-x-annotations" style="width: auto; margin: 0;">
            <span>Tilt X</span>
        </label>
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="tilt-y-annotations" style="width: auto; margin: 0;">
            <span>Tilt Y</span>
        </label>
    </div>

    <div class="control-group">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="axis-markers" checked style="width: auto; margin: 0;">
            <span>Axis</span>
        </label>
    </div>

    <button id="export-btn">Export as PNG</button>
</div>
<div id="viewer">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
    // Scene setup
    const viewer = document.getElementById('viewer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);

    // Cameras
    const cameraAspectRatio = viewer.clientWidth / viewer.clientHeight;
    const cameraNear = 0.1;
    const cameraFar = 1000;
    
    // Perspective camera
    const perspectiveCamera = new THREE.PerspectiveCamera(
        30,
        cameraAspectRatio,
        cameraNear,
        cameraFar
    );
    perspectiveCamera.position.set(0, 15, 25);
    perspectiveCamera.lookAt(0, 0, 0);
    
    // Orthographic camera (axonometric)
    const orthoSize = 20;
    const orthographicCamera = new THREE.OrthographicCamera(
        -orthoSize * cameraAspectRatio,
        orthoSize * cameraAspectRatio,
        orthoSize,
        -orthoSize,
        cameraNear,
        cameraFar
    );
    orthographicCamera.position.set(0, 15, 25);
    orthographicCamera.lookAt(0, 0, 0);
    
    // Active camera (starts with perspective)
    let camera = perspectiveCamera;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    viewer.appendChild(renderer.domElement);

    // Orbit Controls for camera
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 100;
    controls.maxPolarAngle = Math.PI / 2;

    // Lighting
    const ambientLightColor = 0xffffff;
    const directionalLightColor = 0xffffff;
    const pointLightColor = 0xffffff;

    const ambientLight = new THREE.AmbientLight( ambientLightColor, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(directionalLightColor, 0.8);
    directionalLight.position.set(0, 20, 0);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    // Configure shadow camera frustum to cover the entire area where pen can move
    // Tablet is 16" wide, pen can move with offset X from -8 to +8, plus margin
    directionalLight.shadow.camera.left = -15;
    directionalLight.shadow.camera.right = 15;
    directionalLight.shadow.camera.top = 15;
    directionalLight.shadow.camera.bottom = -15;
    directionalLight.shadow.camera.near = 0.1;
    directionalLight.shadow.camera.far = 50;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(pointLightColor, 0.3);
    pointLight.position.set(-10, 10, -10);
    scene.add(pointLight);

    // Create the tablet (16" x 9" x 0.5")

    const geometry = new THREE.BoxGeometry(16, 0.1, 9);
    const material = new THREE.MeshStandardMaterial({
        color: 0x505050,
        roughness: 0.7,
        metalness: 0.2
    });
    const tablet = new THREE.Mesh(geometry, material);
    tablet.castShadow = true;
    tablet.receiveShadow = true;
    scene.add(tablet);

    // Add wireframe to tablet
    const wireframe = new THREE.LineSegments(
        new THREE.EdgesGeometry(geometry),
        new THREE.LineBasicMaterial({ color: 0x808080, linewidth: 1 })
    );
    tablet.add(wireframe);

    // Add grid lines on tablet surface (0.5 inch intervals)
    const gridGroup = new THREE.Group();
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x5a5a5a, linewidth: 1 });

    const tabletWidth = 16; // inches
    const tabletDepth = 9; // inches
    const gridSpacing = 0.5; // inches
    const yOffset = 0.051; // slightly above tablet surface to prevent z-fighting

    // Create vertical lines (parallel to Z axis)
    for (let x = -tabletWidth / 2; x <= tabletWidth / 2; x += gridSpacing) {
        const points = [];
        points.push(new THREE.Vector3(x, yOffset, -tabletDepth / 2));
        points.push(new THREE.Vector3(x, yOffset, tabletDepth / 2));
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, gridMaterial);
        gridGroup.add(line);
    }

    // Create horizontal lines (parallel to X axis)
    for (let z = -tabletDepth / 2; z <= tabletDepth / 2; z += gridSpacing) {
        const points = [];
        points.push(new THREE.Vector3(-tabletWidth / 2, yOffset, z));
        points.push(new THREE.Vector3(tabletWidth / 2, yOffset, z));
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, gridMaterial);
        gridGroup.add(line);
    }

    scene.add(gridGroup);

    // Create the digital pen
    const penGroup = new THREE.Group();

    // Create checkerboard texture for pen
    function createCheckerboardTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const context = canvas.getContext('2d');
        
        const checkSize = 256; // Larger checker squares
        const checksX = canvas.width / checkSize;
        const checksY = canvas.height / checkSize;

        const checkColor1 = '#ee66dd';
        const checkColor2 = '#aa33bb';
        for (let y = 0; y < checksY; y++) {
            for (let x = 0; x < checksX; x++) {
                const isEven = (x + y) % 2 === 0;
                context.fillStyle = isEven ? checkColor1 : checkColor2;
                context.fillRect(x * checkSize, y * checkSize, checkSize, checkSize);
            }
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        return texture;
    }

    const checkerboardTexture = createCheckerboardTexture();
    checkerboardTexture.wrapS = THREE.RepeatWrapping;
    checkerboardTexture.wrapT = THREE.RepeatWrapping;

    // Pen tip (cone)
    const tipHeight = 0.5;
    const tipGeometry = new THREE.ConeGeometry(0.1, tipHeight, 16);
    const tipTexture = checkerboardTexture.clone();
    tipTexture.needsUpdate = true;
    tipTexture.repeat.set(2, 1);
        
    const tipMaterial = new THREE.MeshStandardMaterial({
        map: tipTexture,
        roughness: 0.8,
        metalness: 0.1
    });
    const penTip = new THREE.Mesh(tipGeometry, tipMaterial);
    penTip.castShadow = true;
    penTip.rotation.x = Math.PI;
    penTip.position.y = -tipHeight / 2;
    penGroup.add(penTip);

    // Pen barrel (cylinder)
    const barrelHeight = 4;
    const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, barrelHeight, 16);
    const barrelTexture = checkerboardTexture.clone();
    barrelTexture.needsUpdate = true;
    barrelTexture.repeat.set(2, 2);
        
    const barrelMaterial = new THREE.MeshStandardMaterial({
        map: barrelTexture,
        roughness: 0.8,
        metalness: 0.1
    });
    const penBarrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    penBarrel.castShadow = true;
    penBarrel.position.y = barrelHeight / 2;
    penGroup.add(penBarrel);

    // Position the pen above the tablet
    penGroup.position.set(0, 0, 0);
    scene.add(penGroup);

    // Line from top of pen to tablet surface
    const penLinePositions = new Float32Array(6);
    const penLineGeometry = new THREE.BufferGeometry();
    penLineGeometry.setAttribute('position', new THREE.BufferAttribute(penLinePositions, 3));

    const penLineMaterial = new THREE.LineDashedMaterial({
        color: 0x00ff00,
        dashSize: 0.2,
        gapSize: 0.1
    });
    const penLine = new THREE.Line(penLineGeometry, penLineMaterial);
    scene.add(penLine);

    // Line from pen tip to tablet surface
    const penTipLinePositions = new Float32Array(6);
    const penTipLineGeometry = new THREE.BufferGeometry();
    penTipLineGeometry.setAttribute('position', new THREE.BufferAttribute(penTipLinePositions, 3));

    const penTipLine = new THREE.Line(penTipLineGeometry, penLineMaterial);
    scene.add(penTipLine);

    // Arc annotation on tablet surface
    const arcAnnotationGroup = new THREE.Group();
    const arcRadius = 1.5; // inches
    const arcMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const arcThickness = 0.02; // Thickness of the arc tube in inches
    
    // Create arc curve
    function createArcPoints(centerX, centerZ, radius, startAngle, endAngle, segments) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / segments);
            const x = centerX + radius * Math.cos(angle);
            const z = centerZ + radius * Math.sin(angle);
            points.push(new THREE.Vector3(x, yOffset, z));
        }
        return points;
    }
    
    // Create curve from points for TubeGeometry
    function createCurveFromPoints(points) {
        const curve = new THREE.CatmullRomCurve3(points);
        return curve;
    }
    
    // Create arrow at end of arc
    function createArrow(centerX, centerZ, radius, angle) {
        const arrowHeadLength = 0.3;
        const arrowWidth = 0.15;
        
        const endX = centerX + radius * Math.cos(angle);
        const endZ = centerZ + radius * Math.sin(angle);
        
        // Arrow direction (tangent to arc at end point, pointing in direction arc is growing)
        // Since arc direction is reversed, negate the tangent direction
        const dirX = Math.sin(angle); // Negated from -Math.sin(angle)
        const dirZ = -Math.cos(angle); // Negated from Math.cos(angle)
        
        // Perpendicular direction for arrow head width
        const perpX = Math.cos(angle);
        const perpZ = Math.sin(angle);
        
        // Arrow points: tip at end of arc, then two points forming the arrow head
        const arrowPoints = [
            new THREE.Vector3(endX, yOffset, endZ), // Tip
            new THREE.Vector3(
                endX - arrowHeadLength * dirX - arrowWidth * perpX,
                yOffset,
                endZ - arrowHeadLength * dirZ - arrowWidth * perpZ
            ),
            new THREE.Vector3(
                endX - arrowHeadLength * dirX + arrowWidth * perpX,
                yOffset,
                endZ - arrowHeadLength * dirZ + arrowWidth * perpZ
            ),
            new THREE.Vector3(endX, yOffset, endZ) // Back to tip
        ];
        
        return arrowPoints;
    }
    
    // Create arc as a tube (thick line) instead of a thin line
    const arcGeometry = new THREE.BufferGeometry();
    const arcLine = new THREE.Mesh(arcGeometry, arcMaterial);
    arcAnnotationGroup.add(arcLine);
    
    const arrowMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
    const arrowGeometry = new THREE.BufferGeometry();
    const arrowLine = new THREE.Line(arrowGeometry, arrowMaterial);
    arrowLine.visible = false; // Arrowheads removed
    arcAnnotationGroup.add(arrowLine);
    
    // Dotted arc to complete the remaining part of the circle
    const dottedArcMaterial = new THREE.LineDashedMaterial({ 
        color: 0x00ff00, 
        dashSize: 0.1, 
        gapSize: 0.1,
        linewidth: 2 
    });
    const dottedArcGeometry = new THREE.BufferGeometry();
    const dottedArcLine = new THREE.Line(dottedArcGeometry, dottedArcMaterial);
    arcAnnotationGroup.add(dottedArcLine);
    
    scene.add(arcAnnotationGroup);

    // Line on tablet surface from tip projection to top projection
    const surfaceLineGeometry = new THREE.BufferGeometry();
    const surfaceLineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
    const surfaceLine = new THREE.Line(surfaceLineGeometry, surfaceLineMaterial);
    scene.add(surfaceLine);
    
    // Arrow at end of surface line
    const surfaceArrowGeometry = new THREE.BufferGeometry();
    const surfaceArrowLine = new THREE.Line(surfaceArrowGeometry, surfaceLineMaterial);
    surfaceArrowLine.visible = false; // Arrowheads removed
    scene.add(surfaceArrowLine);
    
    // Helper function to create arrow on surface
    function createSurfaceArrow(startX, startZ, endX, endZ) {
        const arrowHeadLength = 0.3;
        const arrowWidth = 0.15;
        
        // Direction vector from start to end
        const dx = endX - startX;
        const dz = endZ - startZ;
        const length = Math.sqrt(dx * dx + dz * dz);
        
        if (length < 0.001) {
            return []; // Too short, no arrow
        }
        
        // Normalize direction
        const dirX = dx / length;
        const dirZ = dz / length;
        
        // Perpendicular direction for arrow head width
        const perpX = -dirZ;
        const perpZ = dirX;
        
        // Arrow points: tip at end, then two points forming the arrow head
        const arrowPoints = [
            new THREE.Vector3(endX, yOffset, endZ), // Tip
            new THREE.Vector3(
                endX - arrowHeadLength * dirX - arrowWidth * perpX,
                yOffset,
                endZ - arrowHeadLength * dirZ - arrowWidth * perpZ
            ),
            new THREE.Vector3(
                endX - arrowHeadLength * dirX + arrowWidth * perpX,
                yOffset,
                endZ - arrowHeadLength * dirZ + arrowWidth * perpZ
            ),
            new THREE.Vector3(endX, yOffset, endZ) // Back to tip
        ];
        
        return arrowPoints;
    }

    // Barrel rotation annotations (centered on top of pen)
    const barrelAnnotationGroup = new THREE.Group();
    const barrelArcRadius = 1.5; // inches
    const barrelArcThickness = 0.02; // Thickness of the barrel arc tube in inches
    const barrelAnnotationMaterial = new THREE.MeshBasicMaterial({ color: 0xff8800 });
    const barrelArrowMaterial = new THREE.LineBasicMaterial({ color: 0xff8800, linewidth: 2 });
    
    // Create arc points in plane perpendicular to pen axis
    function createBarrelArcPoints(center, axis, u, v, radius, startAngle, endAngle, segments) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / segments);
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            // Point in the perpendicular plane
            const point = center.clone().add(
                u.clone().multiplyScalar(radius * cosA)
            ).add(
                v.clone().multiplyScalar(radius * sinA)
            );
            points.push(point);
        }
        return points;
    }
    
    // Create arrow in plane perpendicular to pen axis
    function createBarrelArrow(center, axis, u, v, radius, angle) {
        const arrowHeadLength = 0.3;
        const arrowWidth = 0.15;
        
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const endPoint = center.clone().add(
            u.clone().multiplyScalar(radius * cosA)
        ).add(
            v.clone().multiplyScalar(radius * sinA)
        );
        
        // Tangent direction in the plane (reversed to point opposite direction)
        const tangent = u.clone().multiplyScalar(sinA).add(v.clone().multiplyScalar(-cosA));
        tangent.normalize();
        
        // Perpendicular direction in the plane for arrow head width
        const perp = u.clone().multiplyScalar(cosA).add(v.clone().multiplyScalar(sinA));
        perp.normalize();
        
        // Arrow points: tip at end of arc, then two points forming the arrow head
        const arrowPoints = [
            endPoint.clone(), // Tip
            endPoint.clone().add(tangent.clone().multiplyScalar(-arrowHeadLength)).add(perp.clone().multiplyScalar(-arrowWidth)),
            endPoint.clone().add(tangent.clone().multiplyScalar(-arrowHeadLength)).add(perp.clone().multiplyScalar(arrowWidth)),
            endPoint.clone() // Back to tip
        ];
        
        return arrowPoints;
    }
    
    // Create line arrow in plane perpendicular to pen axis
    function createBarrelSurfaceArrow(center, direction, axis) {
        const arrowHeadLength = 0.3;
        const arrowWidth = 0.15;
        
        const length = direction.length();
        if (length < 0.001) {
            return []; // Too short, no arrow
        }
        
        const endPoint = center.clone().add(direction);
        const dir = direction.clone().normalize();
        
        // Perpendicular direction in the plane (perpendicular to both dir and axis)
        const perp = new THREE.Vector3().crossVectors(dir, axis).normalize();
        
        // Arrow points: tip at end, then two points forming the arrow head
        const arrowPoints = [
            endPoint.clone(), // Tip
            endPoint.clone().add(dir.clone().multiplyScalar(-arrowHeadLength)).add(perp.clone().multiplyScalar(-arrowWidth)),
            endPoint.clone().add(dir.clone().multiplyScalar(-arrowHeadLength)).add(perp.clone().multiplyScalar(arrowWidth)),
            endPoint.clone() // Back to tip
        ];
        
        return arrowPoints;
    }
    
    // Create barrel arc as a tube (thick line) instead of a thin line
    const barrelArcGeometry = new THREE.BufferGeometry();
    const barrelArcLine = new THREE.Mesh(barrelArcGeometry, barrelAnnotationMaterial);
    barrelAnnotationGroup.add(barrelArcLine);
    
    const barrelArrowGeometry = new THREE.BufferGeometry();
    const barrelArrowLine = new THREE.Line(barrelArrowGeometry, barrelArrowMaterial);
    barrelArrowLine.visible = false; // Arrowheads removed
    barrelAnnotationGroup.add(barrelArrowLine);
    
    // Line from center extending in barrel rotation direction
    const barrelSurfaceLineGeometry = new THREE.BufferGeometry();
    const barrelSurfaceLine = new THREE.Line(barrelSurfaceLineGeometry, barrelArrowMaterial);
    barrelAnnotationGroup.add(barrelSurfaceLine);
    
    const barrelSurfaceArrowGeometry = new THREE.BufferGeometry();
    const barrelSurfaceArrowLine = new THREE.Line(barrelSurfaceArrowGeometry, barrelArrowMaterial);
    barrelSurfaceArrowLine.visible = false; // Arrowheads removed
    barrelAnnotationGroup.add(barrelSurfaceArrowLine);
    
    // Dotted circle for barrel rotation annotations
    const barrelDottedCircleMaterial = new THREE.LineDashedMaterial({ 
        color: 0xff8800, 
        dashSize: 0.1, 
        gapSize: 0.1,
        linewidth: 2 
    });
    const barrelDottedCircleGeometry = new THREE.BufferGeometry();
    const barrelDottedCircleLine = new THREE.Line(barrelDottedCircleGeometry, barrelDottedCircleMaterial);
    barrelAnnotationGroup.add(barrelDottedCircleLine);
    
    scene.add(barrelAnnotationGroup);

    // Fuscia arc from 2 inches above tip to pen body
    const fusciaArcThickness = 0.02; // Thickness of the fuscia arc tube in inches
    const fusciaArcMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    const fusciaArcGeometry = new THREE.BufferGeometry();
    const fusciaArcLine = new THREE.Mesh(fusciaArcGeometry, fusciaArcMaterial);
    scene.add(fusciaArcLine);
    
    // Fuscia vertical line from pen tip to beginning of arc
    const fusciaVerticalLineMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2 });
    const fusciaVerticalLineGeometry = new THREE.BufferGeometry();
    const fusciaVerticalLine = new THREE.Line(fusciaVerticalLineGeometry, fusciaVerticalLineMaterial);
    scene.add(fusciaVerticalLine);
    
    // Fuscia semicircle for tilt altitude annotation (dotted)
    const fusciaSemicircleMaterial = new THREE.LineDashedMaterial({ 
        color: 0xff00ff, 
        dashSize: 0.1, 
        gapSize: 0.1,
        linewidth: 2 
    });
    const fusciaSemicircleGeometry = new THREE.BufferGeometry();
    const fusciaSemicircleLine = new THREE.Line(fusciaSemicircleGeometry, fusciaSemicircleMaterial);
    scene.add(fusciaSemicircleLine);
    
    // Tilt X annotation (light blue)
    const tiltXArcThickness = 0.02; // Thickness of the tilt X arc tube in inches
    const tiltXArcMaterial = new THREE.MeshBasicMaterial({ color: 0x88ccff }); // Light blue
    const tiltXArcGeometry = new THREE.BufferGeometry();
    const tiltXArcLine = new THREE.Mesh(tiltXArcGeometry, tiltXArcMaterial);
    scene.add(tiltXArcLine);
    
    const tiltXVerticalLineMaterial = new THREE.LineBasicMaterial({ color: 0x88ccff, linewidth: 2 });
    const tiltXVerticalLineGeometry = new THREE.BufferGeometry();
    const tiltXVerticalLine = new THREE.Line(tiltXVerticalLineGeometry, tiltXVerticalLineMaterial);
    scene.add(tiltXVerticalLine);
    
    const tiltXDottedCircleMaterial = new THREE.LineDashedMaterial({ 
        color: 0x88ccff, 
        dashSize: 0.1, 
        gapSize: 0.1,
        linewidth: 2 
    });
    const tiltXDottedCircleGeometry = new THREE.BufferGeometry();
    const tiltXDottedCircleLine = new THREE.Line(tiltXDottedCircleGeometry, tiltXDottedCircleMaterial);
    scene.add(tiltXDottedCircleLine);
    
    // Tilt Y annotation (pink)
    const tiltYArcThickness = 0.02; // Thickness of the tilt Y arc tube in inches
    const tiltYArcMaterial = new THREE.MeshBasicMaterial({ color: 0xff88cc }); // Pink
    const tiltYArcGeometry = new THREE.BufferGeometry();
    const tiltYArcLine = new THREE.Mesh(tiltYArcGeometry, tiltYArcMaterial);
    scene.add(tiltYArcLine);
    
    const tiltYVerticalLineMaterial = new THREE.LineBasicMaterial({ color: 0xff88cc, linewidth: 2 });
    const tiltYVerticalLineGeometry = new THREE.BufferGeometry();
    const tiltYVerticalLine = new THREE.Line(tiltYVerticalLineGeometry, tiltYVerticalLineMaterial);
    scene.add(tiltYVerticalLine);
    
    const tiltYDottedCircleMaterial = new THREE.LineDashedMaterial({ 
        color: 0xff88cc, 
        dashSize: 0.1, 
        gapSize: 0.1,
        linewidth: 2 
    });
    const tiltYDottedCircleGeometry = new THREE.BufferGeometry();
    const tiltYDottedCircleLine = new THREE.Line(tiltYDottedCircleGeometry, tiltYDottedCircleMaterial);
    scene.add(tiltYDottedCircleLine);
    
    // Helper function to create circular arc points in a plane
    function createCircularArcInPlane(center, u, v, radius, startAngle, endAngle, segments) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / segments);
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            // Point in the plane: center + radius * (cos(angle) * u + sin(angle) * v)
            const point = center.clone().add(
                u.clone().multiplyScalar(radius * cosA)
            ).add(
                v.clone().multiplyScalar(radius * sinA)
            );
            points.push(point);
        }
        return points;
    }

    const penTopLocal = new THREE.Vector3(0, 4, 0); // barrelHeight = 4
    const penTopWorld = new THREE.Vector3();
    const penLineBottom = new THREE.Vector3();
    const penTipLocal = new THREE.Vector3(0, -0.5, 0); // tipHeight = 0.5
    const penTipWorld = new THREE.Vector3();
    const penTipLineBottom = new THREE.Vector3();

        // Pen tilt parameters
        let tiltAltitude = 30; // degrees
        let tiltAzimuth = 0; // degrees
        let barrelRotation = 0; // degrees
        let tabletOffsetX = 0; // inches
        let tabletOffsetZ = 0; // inches
        let showAltitudeAnnotations = true; // checkbox state
        let showBarrelAnnotations = true; // checkbox state
        let showTiltXAnnotations = false; // checkbox state (unchecked by default)
        let showTiltYAnnotations = false; // checkbox state (unchecked by default)
        
        // Calculate tilt X and tilt Y from tilt altitude and azimuth
        function calculateTiltX(altitude, azimuth) {
            const altRad = (altitude * Math.PI) / 180;
            const azRad = (azimuth * Math.PI) / 180;
            const tiltXRad = Math.atan(Math.tan(altRad) * Math.sin(azRad));
            return (tiltXRad * 180) / Math.PI;
        }
        
        function calculateTiltY(altitude, azimuth) {
            const altRad = (altitude * Math.PI) / 180;
            const azRad = (azimuth * Math.PI) / 180;
            const tiltYRad = Math.atan(Math.tan(altRad) * Math.cos(azRad));
            return (tiltYRad * 180) / Math.PI;
        }

        // Calculate pen position and rotation based on distance and tilt using quaternions
        function updatePenTransform(distance, altitude, azimuth, barrel) {
            // Tablet is at y=0, height is 0.1, so top surface is at y=0.05
            const tabletTopY = 0.05;
            const tipLength = 0.5;
        
            // Convert angles to radians
            const altitudeRad = (altitude * Math.PI) / 180;
            const azimuthRad = (azimuth * Math.PI) / 180;
            const barrelRad = (barrel * Math.PI) / 180;
        
            // The tip contact point on the tablet (fixed in world space)
            const tipContactX = THREE.MathUtils.clamp(tabletOffsetX, -tabletWidth / 2, tabletWidth / 2);
            const tipContactY = tabletTopY + distance;
            const tipContactZ = THREE.MathUtils.clamp(tabletOffsetZ, -tabletDepth / 2, tabletDepth / 2);
        
                // Create quaternions for each rotation
                // Azimuth rotation (around world Y axis)
                const azimuthQuat = new THREE.Quaternion();
                azimuthQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), azimuthRad);
            
                // Altitude rotation (around X axis)
                const altitudeQuat = new THREE.Quaternion();
                altitudeQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), altitudeRad);
            
                // Barrel rotation (around pen's long axis - Y axis in pen's local space)
                const barrelQuat = new THREE.Quaternion();
                barrelQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), barrelRad);
            
                // Combine rotations:
                // 1. Start with barrel rotation (rotate around local Y before tilting)
                // 2. Apply altitude tilt
                // 3. Apply azimuth rotation
                const quaternion = new THREE.Quaternion();
                quaternion.multiplyQuaternions(altitudeQuat, barrelQuat);
                quaternion.premultiply(azimuthQuat);
            
                // Apply quaternion to pen
                penGroup.setRotationFromQuaternion(quaternion);
        
                // Calculate offset from tip to penGroup origin in local pen coordinates
                const tipOffsetLocal = new THREE.Vector3(0, -tipLength, 0);
        
                // Transform this offset to world coordinates using pen's quaternion
                const tipOffsetWorld = tipOffsetLocal.clone().applyQuaternion(quaternion);
        
                // Position penGroup so that tip is at contact point
                penGroup.position.set(
                    tipContactX - tipOffsetWorld.x,
                    tipContactY - tipOffsetWorld.y,
                    tipContactZ - tipOffsetWorld.z
                );
                penGroup.updateMatrixWorld(true);

                penTopWorld.copy(penTopLocal).applyMatrix4(penGroup.matrixWorld);
                penLineBottom.set(penTopWorld.x, tabletTopY, penTopWorld.z);

                penLinePositions[0] = penTopWorld.x;
                penLinePositions[1] = penTopWorld.y;
                penLinePositions[2] = penTopWorld.z;

                penLinePositions[3] = penLineBottom.x;
                penLinePositions[4] = penLineBottom.y;
                penLinePositions[5] = penLineBottom.z;

                // Calculate actual pen tip position in world space
                penTipWorld.copy(penTipLocal).applyMatrix4(penGroup.matrixWorld);
                // Point directly below tip on tablet surface (same X and Z, Y = tabletTopY)
                penTipLineBottom.set(penTipWorld.x, tabletTopY, penTipWorld.z);
                
                // Update fuscia arc from 2 inches above tip to pen body
                // Arc is a circular arc centered at the tip, in the plane formed by the vertical line and the pen's long axis
                
                const arcCenter = penTipWorld.clone();
                const arcRadius = 2.0; // inches
                
                // Get directions for the plane
                const verticalDir = new THREE.Vector3(0, 1, 0);
                const penAxisDir = new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion).normalize();
                
                // Create basis vectors for the plane
                // fusciaU: direction from center to start point (vertical direction, normalized)
                const fusciaU = verticalDir.clone().normalize();
                
                // fusciaV: direction from center to end point (pen axis direction, but we need to make it perpendicular to fusciaU in the plane)
                // Project pen axis onto the plane perpendicular to vertical, then normalize
                const penAxisProjected = penAxisDir.clone().sub(fusciaU.clone().multiplyScalar(penAxisDir.dot(fusciaU)));
                const fusciaV = penAxisProjected.length() > 0.001 ? penAxisProjected.normalize() : new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion).normalize();
                
                // Calculate angles: start is at 0° (vertical up), end is at the angle of the pen axis in the plane
                const fusciaStartAngle = 0; // Vertical direction
                // Calculate angle of pen axis in the plane
                const fusciaEndAngle = Math.atan2(penAxisDir.dot(fusciaV), penAxisDir.dot(fusciaU));
                
                // Calculate angle from pen tip to tablet surface point (where arc should start)
                const tabletSurfaceVec = penTipLineBottom.clone().sub(penTipWorld);
                // Find the angle of this vector in the plane coordinate system
                const tabletSurfaceAngle = Math.atan2(tabletSurfaceVec.dot(fusciaV), tabletSurfaceVec.dot(fusciaU));
                
                // Only show tilt altitude annotations if altitude is not zero and checkbox is checked
                if (altitude !== 0 && showAltitudeAnnotations) {
                    // Create vertical line from pen tip to beginning of arc (straight up vertically)
                    // The beginning of the arc is at angle 0 (vertical up), which is arcRadius distance in the fusciaU direction
                    const arcStartPoint = arcCenter.clone().add(fusciaU.clone().multiplyScalar(arcRadius));
                    const fusciaVerticalLinePoints = [
                        penTipWorld.clone(),
                        arcStartPoint
                    ];
                    fusciaVerticalLineGeometry.setFromPoints(fusciaVerticalLinePoints);
                    fusciaVerticalLineGeometry.attributes.position.needsUpdate = true;
                    fusciaVerticalLine.visible = true;
                    
                    // Create circular arc
                    const fusciaArcPoints = createCircularArcInPlane(arcCenter, fusciaU, fusciaV, arcRadius, fusciaStartAngle, fusciaEndAngle, 32);
                    // Create a curve from the points
                    const fusciaArcCurve = createCurveFromPoints(fusciaArcPoints);
                    // Create a tube geometry along the curve
                    const fusciaTubeGeometry = new THREE.TubeGeometry(fusciaArcCurve, 32, fusciaArcThickness, 8, false);
                    // Dispose old geometry if it exists
                    if (fusciaArcLine.geometry) {
                        fusciaArcLine.geometry.dispose();
                    }
                    fusciaArcLine.geometry = fusciaTubeGeometry;
                    fusciaArcLine.visible = true;
                    
                    // Create dotted fuscia circle (full 360 degrees) that follows the path of the arc
                    const fusciaCircleSegments = 64; // Enough segments for a smooth circle
                    const fusciaCirclePoints = createCircularArcInPlane(arcCenter, fusciaU, fusciaV, arcRadius, 0, 2 * Math.PI, fusciaCircleSegments);
                    fusciaSemicircleGeometry.setFromPoints(fusciaCirclePoints);
                    fusciaSemicircleGeometry.attributes.position.needsUpdate = true;
                    fusciaSemicircleLine.computeLineDistances(); // Required for dashed lines
                    fusciaSemicircleLine.visible = true;
                } else {
                    fusciaVerticalLine.visible = false;
                    fusciaArcLine.visible = false;
                    fusciaSemicircleLine.visible = false;
                }
                
                // Calculate and update tilt X and tilt Y values
                const tiltX = calculateTiltX(altitude, azimuth);
                const tiltY = calculateTiltY(altitude, azimuth);
                document.getElementById('tilt-x-value').textContent = tiltX.toFixed(1);
                document.getElementById('tilt-y-value').textContent = tiltY.toFixed(1);
                
                // Update tilt X annotation (light blue) - in XZ plane
                if (tiltX !== 0 && showTiltXAnnotations) {
                    const tiltXArcCenter = penTipWorld.clone();
                    const tiltXArcRadius = 2.0; // inches
                    // Plane is XZ: u is vertical (Y up), v is horizontal (X direction)
                    const tiltXU = new THREE.Vector3(0, 1, 0); // Vertical up
                    const tiltXV = new THREE.Vector3(1, 0, 0); // X direction
                    
                    // Calculate angle: tilt X is the angle in the XZ plane
                    const tiltXStartAngle = 0; // Vertical up
                    const tiltXEndAngle = (tiltX * Math.PI) / 180; // Tilt X angle
                    
                    // Vertical line from pen tip to beginning of arc
                    const tiltXArcStartPoint = tiltXArcCenter.clone().add(tiltXU.clone().multiplyScalar(tiltXArcRadius));
                    const tiltXVerticalLinePoints = [
                        penTipWorld.clone(),
                        tiltXArcStartPoint
                    ];
                    tiltXVerticalLineGeometry.setFromPoints(tiltXVerticalLinePoints);
                    tiltXVerticalLineGeometry.attributes.position.needsUpdate = true;
                    tiltXVerticalLine.visible = true;
                    
                    // Create circular arc
                    const tiltXArcPoints = createCircularArcInPlane(tiltXArcCenter, tiltXU, tiltXV, tiltXArcRadius, tiltXStartAngle, tiltXEndAngle, 32);
                    const tiltXArcCurve = createCurveFromPoints(tiltXArcPoints);
                    const tiltXTubeGeometry = new THREE.TubeGeometry(tiltXArcCurve, 32, tiltXArcThickness, 8, false);
                    if (tiltXArcLine.geometry) {
                        tiltXArcLine.geometry.dispose();
                    }
                    tiltXArcLine.geometry = tiltXTubeGeometry;
                    tiltXArcLine.visible = true;
                    
                    // Create dotted circle
                    const tiltXCirclePoints = createCircularArcInPlane(tiltXArcCenter, tiltXU, tiltXV, tiltXArcRadius, 0, 2 * Math.PI, 64);
                    tiltXDottedCircleGeometry.setFromPoints(tiltXCirclePoints);
                    tiltXDottedCircleGeometry.attributes.position.needsUpdate = true;
                    tiltXDottedCircleLine.computeLineDistances();
                    tiltXDottedCircleLine.visible = true;
                } else {
                    tiltXVerticalLine.visible = false;
                    tiltXArcLine.visible = false;
                    tiltXDottedCircleLine.visible = false;
                }
                
                // Update tilt Y annotation (pink) - in YZ plane
                if (tiltY !== 0 && showTiltYAnnotations) {
                    const tiltYArcCenter = penTipWorld.clone();
                    const tiltYArcRadius = 2.0; // inches
                    // Plane is YZ: u is vertical (Y up), v is horizontal (Z direction)
                    const tiltYU = new THREE.Vector3(0, 1, 0); // Vertical up
                    const tiltYV = new THREE.Vector3(0, 0, 1); // Z direction
                    
                    // Calculate angle: tilt Y is the angle in the YZ plane
                    const tiltYStartAngle = 0; // Vertical up
                    const tiltYEndAngle = (tiltY * Math.PI) / 180; // Tilt Y angle
                    
                    // Vertical line from pen tip to beginning of arc
                    const tiltYArcStartPoint = tiltYArcCenter.clone().add(tiltYU.clone().multiplyScalar(tiltYArcRadius));
                    const tiltYVerticalLinePoints = [
                        penTipWorld.clone(),
                        tiltYArcStartPoint
                    ];
                    tiltYVerticalLineGeometry.setFromPoints(tiltYVerticalLinePoints);
                    tiltYVerticalLineGeometry.attributes.position.needsUpdate = true;
                    tiltYVerticalLine.visible = true;
                    
                    // Create circular arc
                    const tiltYArcPoints = createCircularArcInPlane(tiltYArcCenter, tiltYU, tiltYV, tiltYArcRadius, tiltYStartAngle, tiltYEndAngle, 32);
                    const tiltYArcCurve = createCurveFromPoints(tiltYArcPoints);
                    const tiltYTubeGeometry = new THREE.TubeGeometry(tiltYArcCurve, 32, tiltYArcThickness, 8, false);
                    if (tiltYArcLine.geometry) {
                        tiltYArcLine.geometry.dispose();
                    }
                    tiltYArcLine.geometry = tiltYTubeGeometry;
                    tiltYArcLine.visible = true;
                    
                    // Create dotted circle
                    const tiltYCirclePoints = createCircularArcInPlane(tiltYArcCenter, tiltYU, tiltYV, tiltYArcRadius, 0, 2 * Math.PI, 64);
                    tiltYDottedCircleGeometry.setFromPoints(tiltYCirclePoints);
                    tiltYDottedCircleGeometry.attributes.position.needsUpdate = true;
                    tiltYDottedCircleLine.computeLineDistances();
                    tiltYDottedCircleLine.visible = true;
                } else {
                    tiltYVerticalLine.visible = false;
                    tiltYArcLine.visible = false;
                    tiltYDottedCircleLine.visible = false;
                }
                
                penTipLinePositions[0] = penTipWorld.x;
                penTipLinePositions[1] = penTipWorld.y;
                penTipLinePositions[2] = penTipWorld.z;
                penTipLinePositions[3] = penTipLineBottom.x;
                penTipLinePositions[4] = penTipLineBottom.y;
                penTipLinePositions[5] = penTipLineBottom.z;

                penLineGeometry.attributes.position.needsUpdate = true;
                penLine.computeLineDistances();
                penTipLineGeometry.attributes.position.needsUpdate = true;
                penTipLine.computeLineDistances();
                
                // Update surface line from tip projection with fixed length
                const fixedLineLength = 2.0; // 2 inches total
                
                const dx = penLineBottom.x - penTipLineBottom.x;
                const dz = penLineBottom.z - penTipLineBottom.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                
                let extendedEndX = penTipLineBottom.x;
                let extendedEndZ = penTipLineBottom.z;
                
                if (length > 0.001) {
                    // Normalize direction and extend to fixed length from tip projection
                    const dirX = dx / length;
                    const dirZ = dz / length;
                    extendedEndX = penTipLineBottom.x + dirX * fixedLineLength;
                    extendedEndZ = penTipLineBottom.z + dirZ * fixedLineLength;
                }
                
                const surfaceLinePoints = [
                    new THREE.Vector3(penTipLineBottom.x, yOffset, penTipLineBottom.z),
                    new THREE.Vector3(extendedEndX, yOffset, extendedEndZ)
                ];
                surfaceLineGeometry.setFromPoints(surfaceLinePoints);
                surfaceLineGeometry.attributes.position.needsUpdate = true;
                
                // Update arrow at end of surface line (arrowheads removed)
                const surfaceArrowPoints = createSurfaceArrow(
                    penTipLineBottom.x, penTipLineBottom.z,
                    extendedEndX, extendedEndZ
                );
                if (surfaceArrowPoints.length > 0) {
                    surfaceArrowGeometry.setFromPoints(surfaceArrowPoints);
                    surfaceArrowGeometry.attributes.position.needsUpdate = true;
                    // surfaceArrowLine.visible = true; // Arrowheads removed
                } else {
                    // surfaceArrowLine.visible = false; // Arrowheads removed
                }
                
                // Update arc annotation
                const arcCenterX = penTipLineBottom.x;
                const arcCenterZ = penTipLineBottom.z;
                
                // Arc starts at 90° (pointing in +Z direction) and extends by azimuth angle (reversed direction)
                const startAngle = Math.PI / 2; // 90 degrees to the right
                const endAngle = Math.PI / 2 - (azimuth * Math.PI) / 180; // Start at 90° and extend by azimuth (reversed)
                const arcLength = Math.abs(azimuth);
                const arcSegments = Math.max(8, Math.floor(arcLength / 5)); // More segments for larger arcs
                
                // Show circle always (same visibility as surface line)
                const dottedCircleSegments = 64; // Enough segments for a smooth circle
                const dottedCirclePoints = createArcPoints(arcCenterX, arcCenterZ, arcRadius, 0, 2 * Math.PI, dottedCircleSegments);
                dottedArcGeometry.setFromPoints(dottedCirclePoints);
                dottedArcGeometry.attributes.position.needsUpdate = true;
                dottedArcLine.computeLineDistances(); // Required for dashed lines
                dottedArcLine.visible = true;
                
                // Show arc if azimuth is significant
                if (arcLength > 0.1) {
                    const arcPoints = createArcPoints(arcCenterX, arcCenterZ, arcRadius, startAngle, endAngle, arcSegments);
                    // Create a curve from the points
                    const arcCurve = createCurveFromPoints(arcPoints);
                    // Create a tube geometry along the curve
                    const tubeGeometry = new THREE.TubeGeometry(arcCurve, arcSegments, arcThickness, 8, false);
                    // Dispose old geometry if it exists
                    if (arcLine.geometry) {
                        arcLine.geometry.dispose();
                    }
                    arcLine.geometry = tubeGeometry;
                    arcLine.visible = true;
                    
                    // Update arrow at end of arc (arrowheads removed)
                    const arrowPoints = createArrow(arcCenterX, arcCenterZ, arcRadius, endAngle);
                    arrowGeometry.setFromPoints(arrowPoints);
                    arrowGeometry.attributes.position.needsUpdate = true;
                    // arrowLine.visible = true; // Arrowheads removed
                } else {
                    // arrowLine.visible = false; // Arrowheads removed
                    arcLine.visible = false;
                }
                
                // Update barrel rotation annotations (centered on top of pen, perpendicular to pen axis)
                const barrelCenter = penTopWorld.clone();
                
                // Get pen's long axis direction (Y axis in pen's local space, transformed to world)
                const penAxis = new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion).normalize();
                
                // Create quaternion for pen orientation without barrel rotation
                // This gives us the orientation of the plane for barrel rotation annotations
                // Order: azimuth * altitude (no barrel rotation)
                const orientationQuat = new THREE.Quaternion();
                orientationQuat.multiplyQuaternions(altitudeQuat, new THREE.Quaternion()); // identity quaternion (no barrel rotation)
                orientationQuat.premultiply(azimuthQuat);
                
                // Transform pen's local X and Z axes using orientation quaternion (without barrel rotation)
                // These give us the basis vectors for the plane perpendicular to pen axis
                const u = new THREE.Vector3(1, 0, 0).applyQuaternion(orientationQuat).normalize();
                const v = new THREE.Vector3(0, 0, 1).applyQuaternion(orientationQuat).normalize();
                
                // Barrel arc starts at 90° and extends by barrel rotation (reversed direction)
                const barrelStartAngle = Math.PI / 2; // 90 degrees
                const barrelEndAngle = Math.PI / 2 - (barrel * Math.PI) / 180; // Start at 90° and extend by barrel rotation (reversed)
                const barrelArcLength = Math.abs(barrel);
                const barrelArcSegments = Math.max(8, Math.floor(barrelArcLength / 5));
                
                // Only show barrel annotations if checkbox is checked
                if (showBarrelAnnotations) {
                    // Only show barrel arc if rotation is significant
                    if (barrelArcLength > 0.1) {
                        const barrelArcPoints = createBarrelArcPoints(barrelCenter, penAxis, u, v, barrelArcRadius, barrelStartAngle, barrelEndAngle, barrelArcSegments);
                        // Create a curve from the points
                        const barrelArcCurve = createCurveFromPoints(barrelArcPoints);
                        // Create a tube geometry along the curve
                        const barrelTubeGeometry = new THREE.TubeGeometry(barrelArcCurve, barrelArcSegments, barrelArcThickness, 8, false);
                        // Dispose old geometry if it exists
                        if (barrelArcLine.geometry) {
                            barrelArcLine.geometry.dispose();
                        }
                        barrelArcLine.geometry = barrelTubeGeometry;
                        barrelArcLine.visible = true;
                        
                        // Update arrow at end of barrel arc (arrowheads removed)
                        const barrelArrowPoints = createBarrelArrow(barrelCenter, penAxis, u, v, barrelArcRadius, barrelEndAngle);
                        barrelArrowGeometry.setFromPoints(barrelArrowPoints);
                        barrelArrowGeometry.attributes.position.needsUpdate = true;
                        // barrelArrowLine.visible = true; // Arrowheads removed
                    } else {
                        // barrelArrowLine.visible = false; // Arrowheads removed
                        barrelArcLine.visible = false;
                    }
                    
                    // Create dotted circle (full 360°) in the plane perpendicular to pen axis
                    const barrelDottedCircleSegments = 64; // Enough segments for a smooth circle
                    const barrelDottedCirclePoints = createBarrelArcPoints(barrelCenter, penAxis, u, v, barrelArcRadius, 0, 2 * Math.PI, barrelDottedCircleSegments);
                    barrelDottedCircleGeometry.setFromPoints(barrelDottedCirclePoints);
                    barrelDottedCircleGeometry.attributes.position.needsUpdate = true;
                    barrelDottedCircleLine.computeLineDistances(); // Required for dashed lines
                    barrelDottedCircleLine.visible = true;
                    
                    // Update barrel surface line (fixed length 1.5 inches from center in the perpendicular plane)
                    const barrelFixedLineLength = 1.5; // inches
                    const barrelDir = u.clone().multiplyScalar(Math.cos(barrelEndAngle)).add(v.clone().multiplyScalar(Math.sin(barrelEndAngle)));
                    barrelDir.normalize();
                    const barrelDirection = barrelDir.multiplyScalar(barrelFixedLineLength);
                    
                    const barrelSurfaceLinePoints = [
                        barrelCenter.clone(),
                        barrelCenter.clone().add(barrelDirection)
                    ];
                    barrelSurfaceLineGeometry.setFromPoints(barrelSurfaceLinePoints);
                    barrelSurfaceLineGeometry.attributes.position.needsUpdate = true;
                    barrelSurfaceLine.visible = true;
                    
                    // Update arrow at end of barrel surface line (arrowheads removed)
                    const barrelSurfaceArrowPoints = createBarrelSurfaceArrow(barrelCenter, barrelDirection, penAxis);
                    if (barrelSurfaceArrowPoints.length > 0) {
                        barrelSurfaceArrowGeometry.setFromPoints(barrelSurfaceArrowPoints);
                        barrelSurfaceArrowGeometry.attributes.position.needsUpdate = true;
                        // barrelSurfaceArrowLine.visible = true; // Arrowheads removed
                    } else {
                        // barrelSurfaceArrowLine.visible = false; // Arrowheads removed
                    }
                } else {
                    // Hide all barrel annotations
                    barrelArcLine.visible = false;
                    barrelArrowLine.visible = false;
                    barrelDottedCircleLine.visible = false;
                    barrelSurfaceLine.visible = false;
                    barrelSurfaceArrowLine.visible = false;
                }
            }

        // Initialize pen position
        updatePenTransform(0, tiltAltitude, tiltAzimuth, barrelRotation);

    // Pen distance slider
    const penDistanceSlider = document.getElementById('pen-distance');
    const distanceValueDisplay = document.getElementById('distance-value');

    penDistanceSlider.addEventListener('input', (e) => {
        const distance = parseFloat(e.target.value);
        distanceValueDisplay.textContent = distance.toFixed(1);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });

        // Barrel rotation slider
        const barrelRotationSlider = document.getElementById('barrel-rotation');
        const barrelRotationValueDisplay = document.getElementById('barrel-rotation-value');

        barrelRotationSlider.addEventListener('input', (e) => {
            barrelRotation = parseFloat(e.target.value);
            barrelRotationValueDisplay.textContent = barrelRotation.toFixed(0);
            const distance = parseFloat(penDistanceSlider.value);
            updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
        });

    // Tilt azimuth slider
    const tiltAzimuthSlider = document.getElementById('tilt-azimuth');
    const azimuthValueDisplay = document.getElementById('azimuth-value');

    // Function to update azimuth slider enabled state based on altitude
    function updateAzimuthSliderState() {
        if (tiltAltitude === 0) {
            tiltAzimuthSlider.disabled = true;
            tiltAzimuthSlider.style.opacity = '0.5';
            tiltAzimuthSlider.style.cursor = 'not-allowed';
        } else {
            tiltAzimuthSlider.disabled = false;
            tiltAzimuthSlider.style.opacity = '1';
            tiltAzimuthSlider.style.cursor = 'pointer';
        }
    }

    tiltAzimuthSlider.addEventListener('input', (e) => {
        tiltAzimuth = parseFloat(e.target.value);
        azimuthValueDisplay.textContent = tiltAzimuth.toFixed(0);
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });

    // Tilt altitude slider
    const tiltAltitudeSlider = document.getElementById('tilt-altitude');
    const altitudeValueDisplay = document.getElementById('altitude-value');

    tiltAltitudeSlider.addEventListener('input', (e) => {
        tiltAltitude = parseFloat(e.target.value);
        altitudeValueDisplay.textContent = tiltAltitude.toFixed(0);
        const distance = parseFloat(penDistanceSlider.value);
        updateAzimuthSliderState(); // Update azimuth slider state when altitude changes
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });
    
    // Initialize azimuth slider state
    updateAzimuthSliderState();

    // Tablet position sliders
    const tabletPositionXSlider = document.getElementById('tablet-position-x');
    const tabletPositionXValueDisplay = document.getElementById('tablet-position-x-value');
    const tabletPositionZSlider = document.getElementById('tablet-position-z');
    const tabletPositionZValueDisplay = document.getElementById('tablet-position-z-value');

    tabletPositionXSlider.addEventListener('input', (e) => {
        tabletOffsetX = parseFloat(e.target.value);
        tabletPositionXValueDisplay.textContent = tabletOffsetX.toFixed(1);
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });

    tabletPositionZSlider.addEventListener('input', (e) => {
        tabletOffsetZ = parseFloat(e.target.value);
        tabletPositionZValueDisplay.textContent = tabletOffsetZ.toFixed(1);
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });

    // Grid helper
    const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
    gridHelper.position.y = -5;
    scene.add(gridHelper);

    // Axes helper
    //const axesHelper = new THREE.AxesHelper(9);
    //scene.add(axesHelper);



    // Add axis labels
    function createTextLabel(text, color, position) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 64;

        context.fillStyle = color;
        context.font = 'Bold 16px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.scale.set(2, 2, 1);

        return sprite;
    }

    // Z,Y labels swapped to match how screen coordinates and tablet think about space
    const xLabelUser = 'X';
    const yLabelUser = 'Z';
    const zLabelUser = 'Y';

    // Position arrows just beyond the top left corner of the tablet
    // Tablet is 16" × 9", centered at origin, so top left is at (-8, 0.05, 4.5)
    // Position arrows on the other side (front/bottom) along the Z axis
    // Note: tabletWidth and tabletDepth are already defined above
    const tabletTopY = 0.05; // top surface Y coordinate
    const arrowOffset = 0.5; // inches beyond the corner
    const arrowPos = new THREE.Vector3(
        -tabletWidth / 2 - arrowOffset,  // Just to the left of left edge
        tabletTopY,                      // On tablet surface
        -tabletDepth / 2 - arrowOffset   // Just beyond the bottom/front edge (opposite side)
    );

    const xLabelDistance = 3;
    const yLabelDistance = 3;
    const zLabelDistance = 3;

    const xAxisColor = '#cc0055';
    const yAxisColor = '#00cc66';
    const zAxisColor = '#0055cc';
    // axis labels - positioned at the end of each arrow from the new origin
    const xLabel = createTextLabel(xLabelUser, xAxisColor, arrowPos.clone().add(new THREE.Vector3(xLabelDistance, 0, 0)));
    const yLabel = createTextLabel( yLabelUser , yAxisColor, arrowPos.clone().add(new THREE.Vector3(0, yLabelDistance, 0)));
    const zLabel = createTextLabel(zLabelUser, zAxisColor , arrowPos.clone().add(new THREE.Vector3(0, 0, zLabelDistance)));

    scene.add(xLabel);
    scene.add(yLabel);
    scene.add(zLabel);
    const arrowGap = 0.5;
    const xArrow = new THREE.ArrowHelper(
        new THREE.Vector3(1, 0, 0), // Direction
        arrowPos,                   // Origin
        xLabelDistance-arrowGap ,             // Length
        xAxisColor                    // Color
    );

    const yArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 1, 0), // Direction
        arrowPos,                   // Origin
        yLabelDistance-arrowGap ,             // Length
        yAxisColor                  // Color
    );

    const zArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, 1), // Direction
        arrowPos,                   // Origin
        zLabelDistance-arrowGap,             // Length
        zAxisColor                  // Color
    );
    scene.add(xArrow);
    scene.add(yArrow);
    scene.add(zArrow);

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        // Update controls
        controls.update();

        renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
        const aspect = viewer.clientWidth / viewer.clientHeight;
        
        // Update perspective camera
        perspectiveCamera.aspect = aspect;
        perspectiveCamera.updateProjectionMatrix();
        
        // Update orthographic camera
        orthographicCamera.left = -orthoSize * aspect;
        orthographicCamera.right = orthoSize * aspect;
        orthographicCamera.updateProjectionMatrix();
        
        renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    });
    
    // Axonometric view checkbox
    const axonometricCheckbox = document.getElementById('axonometric-view');
    axonometricCheckbox.addEventListener('change', (e) => {
        const isAxonometric = e.target.checked;
        
        if (isAxonometric) {
            // Switch to orthographic
            // Copy position and rotation from perspective camera
            orthographicCamera.position.copy(perspectiveCamera.position);
            orthographicCamera.rotation.copy(perspectiveCamera.rotation);
            camera = orthographicCamera;
        } else {
            // Switch to perspective
            // Copy position and rotation from orthographic camera
            perspectiveCamera.position.copy(orthographicCamera.position);
            perspectiveCamera.rotation.copy(orthographicCamera.rotation);
            camera = perspectiveCamera;
        }
        
        // Update controls to use new camera
        controls.object = camera;
        controls.update();
    });
    
    // Tilt azimuth annotations visibility checkbox
    const azimuthAnnotationsCheckbox = document.getElementById('azimuth-annotations');
    azimuthAnnotationsCheckbox.addEventListener('change', (e) => {
        const isVisible = e.target.checked;
        arcAnnotationGroup.visible = isVisible;
        surfaceLine.visible = isVisible;
        // surfaceArrowLine.visible = isVisible; // Arrowheads removed
    });
    
    // Tilt altitude annotations visibility checkbox
    const altitudeAnnotationsCheckbox = document.getElementById('altitude-annotations');
    altitudeAnnotationsCheckbox.addEventListener('change', (e) => {
        showAltitudeAnnotations = e.target.checked;
        // Update visibility immediately and trigger a pen transform update
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });
    
    // Barrel rotation annotations visibility checkbox
    const barrelAnnotationsCheckbox = document.getElementById('barrel-annotations');
    barrelAnnotationsCheckbox.addEventListener('change', (e) => {
        showBarrelAnnotations = e.target.checked;
        // Update visibility immediately and trigger a pen transform update
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });
    
    // Tilt X annotations visibility checkbox
    const tiltXAnnotationsCheckbox = document.getElementById('tilt-x-annotations');
    tiltXAnnotationsCheckbox.addEventListener('change', (e) => {
        showTiltXAnnotations = e.target.checked;
        // Update visibility immediately and trigger a pen transform update
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });
    
    // Tilt Y annotations visibility checkbox
    const tiltYAnnotationsCheckbox = document.getElementById('tilt-y-annotations');
    tiltYAnnotationsCheckbox.addEventListener('change', (e) => {
        showTiltYAnnotations = e.target.checked;
        // Update visibility immediately and trigger a pen transform update
        const distance = parseFloat(penDistanceSlider.value);
        updatePenTransform(distance, tiltAltitude, tiltAzimuth, barrelRotation);
    });
    
    // Axis markers visibility checkbox
    const axisMarkersCheckbox = document.getElementById('axis-markers');
    axisMarkersCheckbox.addEventListener('change', (e) => {
        const isVisible = e.target.checked;
        xArrow.visible = isVisible;
        yArrow.visible = isVisible;
        zArrow.visible = isVisible;
        xLabel.visible = isVisible;
        yLabel.visible = isVisible;
        zLabel.visible = isVisible;
    });

    // Export as PNG
    document.getElementById('export-btn').addEventListener('click', () => {
        renderer.render(scene, camera);
        const dataURL = renderer.domElement.toDataURL('image/png');

        const link = document.createElement('a');
        link.download = 'Pen3DSim-render.png';
        link.href = dataURL;
        link.click();
    });
</script>
</body>
</html>